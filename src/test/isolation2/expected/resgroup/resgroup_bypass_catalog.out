CREATE RESOURCE GROUP rg_test_catalog WITH (CONCURRENCY=2, cpu_rate_limit=10);
CREATE
CREATE ROLE role_test_catalog RESOURCE GROUP rg_test_catalog;
CREATE

CREATE FUNCTION rg_test_udf() RETURNS integer AS $$ SELECT 1; $$ LANGUAGE SQL;
CREATE

-- take 1 slot
1: SET ROLE role_test_catalog;
SET
1: BEGIN;
BEGIN

-- take another slot
2: SET ROLE role_test_catalog;
SET
2: BEGIN;
BEGIN

-- two slot have all been taken, so this query will be hung up.
3: SET ROLE role_test_catalog;
SET
3&: BEGIN;  <waiting ...>

-- It's a catalog only query, so it will be bypassed.
4: SET ROLE role_test_catalog;
SET
4: SELECT 1 FROM pg_catalog.pg_rules;
 ?column? 
----------
 1        
 1        
(2 rows)

-- It's a udf only query, will be hung up.
-- Because there is no RangeVar, it doesn't belong to catalog only query.
5: SET ROLE role_test_catalog;
SET
5&: SELECT rg_test_udf();  <waiting ...>

-- turn of bypass catalog query
6: SET ROLE role_test_catalog;
SET
6: SET gp_resource_group_bypass_catalog_query = false;
SET
6&: SELECT 1 FROM pg_catalog.pg_rules;  <waiting ...>

1: COMMIT;
COMMIT
2: COMMIT;
COMMIT
3<:  <... completed>
BEGIN
3: COMMIT;
COMMIT
5<:  <... completed>
 rg_test_udf 
-------------
 1           
(1 row)
5: COMMIT;
COMMIT
6<:  <... completed>
 ?column? 
----------
 1        
 1        
(2 rows)

ALTER RESOURCE GROUP rg_test_catalog SET CONCURRENCY 1;
ALTER

-- Session1: pure-catalog query will be unassigned and bypassed.
1: SET ROLE role_test_catalog;
SET
1: SELECT gp_inject_fault('check_and_unassign_from_resgroup_entry', 'suspend', 1, current_setting('gp_session_id')::int);
 gp_inject_fault 
-----------------
 Success:        
(1 row)
1&: SELECT relname FROM pg_class where relname='pg_class';  <waiting ...>

SELECT gp_wait_until_triggered_fault('check_and_unassign_from_resgroup_entry', 1, 1);
 gp_wait_until_triggered_fault 
-------------------------------
 Success:                      
(1 row)

2: SET ROLE role_test_catalog;
SET
2&: BEGIN;  <waiting ...>

SELECT gp_inject_fault('check_and_unassign_from_resgroup_end', 'suspend', 1, sess_id) FROM pg_stat_activity WHERE rsgname = 'rg_test_catalog' AND waiting = false;
 gp_inject_fault 
-----------------
 Success:        
(1 row)

SELECT gp_inject_fault('check_and_unassign_from_resgroup_entry', 'reset', 1);
 gp_inject_fault 
-----------------
 Success:        
(1 row)

2<:  <... completed>
BEGIN
2: COMMIT;
COMMIT

SELECT gp_inject_fault('check_and_unassign_from_resgroup_end', 'reset', 1);
 gp_inject_fault 
-----------------
 Success:        
(1 row)

1<:  <... completed>
 relname  
----------
 pg_class 
(1 row)
1q: ... <quitting>
2q: ... <quitting>

-- simple query (no rangetable and no function) will be unassigned and bypassed
1: SET ROLE role_test_catalog;
SET
1: SELECT gp_inject_fault('check_and_unassign_from_resgroup_entry', 'suspend', 1, current_setting('gp_session_id')::int);
 gp_inject_fault 
-----------------
 Success:        
(1 row)
1&: SELECT 1;  <waiting ...>

SELECT gp_wait_until_triggered_fault('check_and_unassign_from_resgroup_entry', 1, 1);
 gp_wait_until_triggered_fault 
-------------------------------
 Success:                      
(1 row)

2: SET ROLE role_test_catalog;
SET
2&: BEGIN;  <waiting ...>

SELECT gp_inject_fault('check_and_unassign_from_resgroup_end', 'suspend', 1, sess_id) FROM pg_stat_activity WHERE rsgname = 'rg_test_catalog' AND waiting = false;
 gp_inject_fault 
-----------------
 Success:        
(1 row)

SELECT gp_inject_fault('check_and_unassign_from_resgroup_entry', 'reset', 1);
 gp_inject_fault 
-----------------
 Success:        
(1 row)

2<:  <... completed>
BEGIN
2: COMMIT;
COMMIT

SELECT gp_inject_fault('check_and_unassign_from_resgroup_end', 'reset', 1);
 gp_inject_fault 
-----------------
 Success:        
(1 row)

1<:  <... completed>
 ?column? 
----------
 1        
(1 row)
1q: ... <quitting>
2q: ... <quitting>
-- test for Github Issue 15416
-- following SQLs should not throw "unrecognized node type" error.
create table t_15416(s int);
CREATE
-- test for T_GroupingFunc
select count(), grouping(s) from t_15416 group by s;
 count | grouping 
-------+----------
(0 rows)
-- test for T_GroupingClause
select 1 from pg_catalog.pg_class group by rollup(1);
 ?column? 
----------
 1        
          
(2 rows)
-- test for T_TableValueExpr
-- don't want spend time on create a UDF below, the below SQL
-- should not throw  "unrecognized node type" error, this is the test point.
select count(1) from anytable_out( table(select * from t_15416 scatter by s) );
ERROR:  cannot display a value of type anytable  (seg0 slice1 127.0.1.1:6002 pid=1922087)
-- test for T_GroupId
select group_id() from t_15416;
 ?column? 
----------
(0 rows)

-- cleanup
-- start_ignore
DROP ROLE role_test_catalog;
DROP
DROP RESOURCE GROUP rg_test_catalog;
DROP
DROP FUNCTION rg_test_udf();
DROP
DROP TABLE t_15416;
DROP
-- end_ignore
